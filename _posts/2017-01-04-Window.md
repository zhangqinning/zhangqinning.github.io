---
layout: post
title: Android窗口机制
categories: [Android]
description: 
keywords: Window,Android
---

Android的窗口机制涉及到方方面面的知识，比如Activity的管理、View添加、权限、事件各个方面，比较复杂。本文从WindowManager的三个常用方法入手，找到一条清晰的线路来认识Android的窗口机制，当了解到Android FrameWork层的设计思路以后，再去仔细研究某一部分会相对轻松一些。

窗口的概念：

* 对于用户来说，就是手机屏幕一次展示的内容
* 对应Activity来说，窗口就是除去系统状态栏、系统按键的区域
* 对于WMS来说，它已经没有窗口的概念了，它能接受的是一个个View而已

<!--通常我们认为显示在界面上的是 View，这么说本身没有什么问题，但更准确的说法是 WindowManager 通过 ViewRoot 将 View 和 Window 协同整合在一起，最终将 View 展示在 Window 上面。正如 Window 这个名字，就是窗口的意思，我们所见的所有东西都要展示在 Window 上，熟知的 Dialog、Activity 以及 Toast 都是展示在 Window 上面的。

Window 表示一个窗口的概念。
Window是一个抽象类，它的具体实现是PhoneWindow，创建Window通过WindowManager完成。
WindowManager是外界访问Window的入口，Window的具体实现位于WindowManagerService中，而WindowManager和WindowManagerService 的交互是一个IPC过程。
-->

<!--Activity、Dialog、Toast都是通过Window来呈现的。他们的视图都是附加在Window上的。比如，Activity的setContentView的底层也是通过Window来完成的-->


## 常见使用方法

比如把一个Button添加到屏幕上通常这做：

```java
mFloatingButton = new Button(this);
           mFloatingButton.setText( "window");
           mLayoutParams = new WindowManager.LayoutParams(
                   LayoutParams. WRAP_CONTENT, LayoutParams.WRAP_CONTENT, 0, 0,
                   PixelFormat. TRANSPARENT);
           mLayoutParams. flags = LayoutParams.FLAG_NOT_TOUCH_MODAL
                   | LayoutParams. FLAG_NOT_FOCUSABLE
                   | LayoutParams. FLAG_SHOW_WHEN_LOCKED;
           mLayoutParams. type = LayoutParams. TYPE_SYSTEM_ERROR;
           mLayoutParams. gravity = Gravity. LEFT | Gravity. TOP;
           mLayoutParams. x = 100;
           mLayoutParams. y = 300;
           mFloatingButton.setOnTouchListener( this);
mWindowManager.addView( mFloatingButton, mLayoutParams);
```

## WindowManager.LayoutParams

WindowManager.LayoutParams是 WindowManager 接口的嵌套类，在窗口管理中扮演着重要的角色。它继承于ViewGroup.LayoutParams，它用于向WindowManager描述窗口的管理策略；WindowManager.LayoutParams可以直接new WindowManager.LayoutParams()新建，也可以从对窗口的getAttributes()得到其WindowManager.LayoutParams对象。

### flags

* WindowManager.LayoutParams.FLAG_SECURE 
不允许截屏；设置了这个属性的窗口，在窗口可见的情况下，是会禁用系统的截图功能的。那么问题来了：假如有一天，你的公司要求写一个类似于‘阅后即焚’功能的页面的话，不妨在activity中获得WindowManager.LayoutParams并添加该属性，轻轻松松搞定。

* WindowManager.LayoutParams.FLAG_BLUR_BEHIND 
背景模糊；假如你的窗口设置了这个属性，并且这个窗口可见，在这窗口之后的所有背景都会被模糊化，但我还没有发现一个属性是可以控制模糊程度的。

* WindowManager.LayoutParams.FLAG_DIM_BEHIND 
背景变暗；设置这个效果的窗口，在窗口可见的情况下，窗口后方的背景会相应的变暗，这个属性需要配合参数dimAmount一起使用，dimAmount会在后文中介绍。
* WindowManager.LayoutParams.FLAG_FULLSCREEN 
设置全屏；这个属性也许是大家接触的最多的一个属性，很多应用开发过程中会要求有些页面需要动态设置Activity为全屏，而我们只需要获得Activity的WindowManager.LayoutParams并设置WindowManager.LayoutParams.FLAG_FULLSCREEN属性就行。
* WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON 
设备常亮；设置这个属性的窗口，在窗口可见的情况下，整个屏幕会处于常亮并且高亮度的状态，并且不受待机时间的约束。
* WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS 
布局不受限制；设置这个属性的窗口，将不再受设备显示范围边界 的约束，通俗点讲，就是窗口可以出设备之外，然后移除部分不可见。具体会在坐标参数中讲到。
* WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE 
不设置聚焦；关于焦点获得我有必要说明一下，如果窗口获得焦点的话，只要窗口处于可视化状态，当前设备的物理按键点击事件都会被这个窗口接收，但是如果不设置窗口的焦点的话，直接传递到之后窗口进行接收。这就导致一个问题，如果你的需求要求你写的悬浮窗点击返回键能够关闭或是进行其他操作的话，你就必须让你的窗口获得焦点，并为当前View设置按键监听事件。
* WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE 
取消触摸事件； 设置这个属性的窗口将不再处理任何Touch事件，就算显示的View设置了onTouch事件，那么这个窗口就会是一个僵尸窗口。
* WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL 
不知道怎么去归纳，这个属性还是比较有意思的，设置这个属性的窗口，在窗口可见的情况下，就算窗口没有设置属性FLAG_NOT_FOCUSABLE，(也就是在窗口获得焦点的情况下)当触摸事件是在窗口之外区域的时候，窗口不在拦截触摸事件，而是将事件往下传递，也算是解决聚焦后的事件拦截问题吧。

* WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON 
点亮屏幕；设置这个属性的窗口，当窗口显示的时候，如果设备处于待机状态，会点亮设备。这个应该在很多锁屏窗口中用的比较多，比如收到消息点亮屏幕。

* WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
 这个也不知道怎么去归纳，也是一个比较有意思的属性，之前我们说到FLAG_NOT_TOUCH_MODAL，在窗口获得焦点的情况下，当触摸事件是在窗口之外区域的时候，窗口不在拦截触摸事件，而是将事件往下传递，而如果再设置这个属性，窗口能在MotionEvent.ACTION_OUTSIDE中收获窗口之外的点击事件，遗憾的是不能进行屏蔽，也就是说事件依然会向下传递。

### type

type表示Window的类型。

* 三种类型：应用Window、子Window和系统Window。
* 应用Window对应Activity
* 子Window不能单独存在，必须附属在特定的父Window里，比如Dialog。
* 系统Window是需要声明特殊权限才能创建的Window，比如Toast和系统状态栏。
* Window有层级关系，每个Window都对应的Z轴上的序列。层级大的会覆盖在层级比较小的Window的上面
* 应用Window范围 1-99
* 子Window的层级范围 1000-1999
* 系统Window的层级范围 2000-2999
* 层级范围对应着WindowManager.LayouParams的type参数
* 系统Window层级的值：TYPE_SYSTEM_OVERLAY/TYPE_SYSTME_ERROR  权限：<users-permission android:name ="android.permission.SYSTEM_ALTER_WINDOW"/>

<!--### Token
开发中会遇到Bad ToKen的错误，那么Token到底是什么，其实大多数的token代表的是IBinder的对象，Ibinder也就是Android的IPC机制。

而在窗口系统中，关于这方面会涉及到的IPC无非是这两个：一个是 WmS 用来跟应用所在的进程进行通信的 ViewRootImpl.W 类的对象，另一个是指向一个 ActivityRecord 的对象，自然应该是WmS用来跟 AmS 进行通信的了。
<img src="/images/posts/Android_Window/1.png" width="80%"/>
ViewRootImpl 在构建方法里，会初始化一个 AttachInfo 实例，把它的 Session，以及 W类对象赋值给 AttachInfo。分析可以看到，AttachInfo 中的 mWindowToken，与mWindow 都是指向 ViewRootImpl 中的 mWindow(W类实例)。当一个 View attach 到窗口后，ViewRootImpl会执行performTraversals，如果发现是首次调用会，会把自己的 mAttachInfo 传递给根 View（通过dispatchAttachedToWindow），告诉 View 树现在已经 attch to Window 了，马上可以显示了。根 View（一般是 ViewGroup）会把这个信息，遍历地传递给 View 树中的每一个子 View，这样每个 View 的 mAttachInfo 都被赋值为 ViewRootImp 的 mAttachInfo了。

```java
//分析一下 View 中的 AttachInfo 的赋值，以及 ViewRootImpl 中的 mAttachInfo
    public ViewRootImpl(Context context, Display display) {
        ...
        mWindow = new W(this);
        ...
         mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);
        ...
    }
    //看到mWindowToken其实就是IWindow实例
    AttachInfo(IWindowSession session, IWindow window, Display display,
                 ViewRootImpl viewRootImpl, Handler handler, Callbacks effectPlayer) {
           mSession = session;
           mWindow = window;
           mWindowToken = window.asBinder();
           mDisplay = display;
           mViewRootImpl = viewRootImpl;
           mHandler = handler;
           mRootCallbacks = effectPlayer;
    }
    // ViewRootImpl在第一次执行performTraversals时，会把自己的mAttachInfo传递给根View,然后由根View逐级传递下去
    private void performTraversals() {
       ...
        if (mFirst) {
            ...
            host.dispatchAttachedToWindow(mAttachInfo, 0);
            ...
        }else{
            ...
        }
    }
    //ViewGroup.java
    void dispatchAttachedToWindow(AttachInfo info, int visibility) {
       mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
       super.dispatchAttachedToWindow(info, visibility);
       mGroupFlags &= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
       final int count = mChildrenCount;
       final View[] children = mChildren;
       for (int i = 0; i < count; i++) {
           final View child = children[i];
           child.dispatchAttachedToWindow(info,
                   visibility | (child.mViewFlags & VISIBILITY_MASK));
      }
    }
    //View.java
    void dispatchAttachedToWindow(AttachInfo info, int visibility) {
       mAttachInfo = info;
       ...
     }
```
在View获得Token的之后，看看代码

```java
    //WindowManagerService.java addWindow 
    ...
    //权限检查，需要用到type类型，会检查窗口类型是否合法，如果是系统窗口类型
    //还需要进行权限检查，详见PhoneWindowManager.java
    int res = mPolicy.checkAddPermission(attrs, appOp);
    ...
    //如果是子窗口类型，还会检查其父窗口是否存在，如果父窗口不存在，直接抛出异常
    if (type >= FIRST_SUB_WINDOW && type <= LAST_SUB_WINDOW) {
                attachedWindow = windowForClientLocked(null, attrs.token, false);
                if (attachedWindow == null) {
                     Slog.w(TAG, "Attempted to add window with token that is not a window: " + attrs.token + ".  Aborting.");
                     return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
                 }
                 if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW
                       && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
                    Slog.w(TAG, "Attempted to add window with token that is a sub-window: " + attrs.token + ".  Aborting.");
                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;
                 }
      }
      ...
     //如果是类型是TYPE_PRIVATE_PRESENTATION ，还会检查相应的显示设备
     if (type == TYPE_PRIVATE_PRESENTATION && !displayContent.isPrivate()) {
            Slog.w(TAG, "Attempted to add private presentation window to a non-private display.  Aborting.");
            return WindowManagerGlobal.ADD_PERMISSION_DENIED;
        }
     ...    
    //根据LayoutParams中的token，会检索WmS中保存的WindowToken，
    //由引可见，不同的窗口类型，其对应的token是有区别的。WmS要根据窗口类型来检查其传递过来的token是否合法。
    boolean addToken = false;
    WindowToken token = mTokenMap.get(attrs.token);
    if (token == null) {
       if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
                Slog.w(TAG, "Attempted to add application window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
    if (type == TYPE_INPUT_METHOD) {
                Slog.w(TAG, "Attempted to add input method window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
    if (type == TYPE_VOICE_INTERACTION) {
                Slog.w(TAG, "Attempted to add voice interaction window with unknown token "+ attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
    if (type == TYPE_WALLPAPER) {
                Slog.w(TAG, "Attempted to add wallpaper window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
    if (type == TYPE_DREAM) {
                Slog.w(TAG, "Attempted to add Dream window with unknown token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
    if (type == TYPE_ACCESSIBILITY_OVERLAY) {
                Slog.w(TAG, "Attempted to add Accessibility overlay window with unknown token "  + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            token = new WindowToken(this, attrs.token, -1, false);
            addToken = true;
    } else if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
            AppWindowToken atoken = token.appWindowToken;
            if (atoken == null) {
                Slog.w(TAG, "Attempted to add window with non-application token " + token + ".  Aborting.");
                return WindowManagerGlobal.ADD_NOT_APP_TOKEN;
            } else if (atoken.removed) {
                Slog.w(TAG, "Attempted to add window with exiting application token "  + token + ".  Aborting.");
                return WindowManagerGlobal.ADD_APP_EXITING;
            }
            if (type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
                // No need for this guy!
                if (localLOGV) Slog.v(
                        TAG, "**** NO NEED TO START: " + attrs.getTitle());
                return WindowManagerGlobal.ADD_STARTING_NOT_NEEDED;
            }
        } else if (type == TYPE_INPUT_METHOD) {
            if (token.windowType != TYPE_INPUT_METHOD) {
                Slog.w(TAG, "Attempted to add input method window with bad token "  + attrs.token + ".  Aborting.");
                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (type == TYPE_VOICE_INTERACTION) {
            if (token.windowType != TYPE_VOICE_INTERACTION) {
                Slog.w(TAG, "Attempted to add voice interaction window with bad token "  + attrs.token + ".  Aborting.");
                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (type == TYPE_WALLPAPER) {
            if (token.windowType != TYPE_WALLPAPER) {
                Slog.w(TAG, "Attempted to add wallpaper window with bad token "   + attrs.token + ".  Aborting.");
                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (type == TYPE_DREAM) {
            if (token.windowType != TYPE_DREAM) {
                Slog.w(TAG, "Attempted to add Dream window with bad token " + attrs.token + ".  Aborting.");
                  return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (type == TYPE_ACCESSIBILITY_OVERLAY) {
            if (token.windowType != TYPE_ACCESSIBILITY_OVERLAY) {
                Slog.w(TAG, "Attempted to add Accessibility overlay window with bad token " + attrs.token + ".  Aborting.");
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
        } else if (token.appWindowToken != null) {
            Slog.w(TAG, "Non-null appWindowToken for system window of type=" + type);
            // It is not valid to use an app token with other system types; we will
            // instead make a new token for it (as if null had been passed in for the token).
            attrs.token = null;
            token = new WindowToken(this, null, -1, false);
            addToken = true;
        }   
      ...
    //经过一系列的检查之后，最后会生成窗口在WmS中的表示WindowState，并且把LayoutParams赋值给WindowState的mAttrs
    win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);  
    ...  
    if (addToken) {
     mTokenMap.put(attrs.token, token);
    } 
    ...
     mWindowMap.put(client.asBinder(), win);   

```
-->


## 三个重要的方法

```java
public interface ViewManager
{
    /**
     * Assign the passed LayoutParams to the passed View and add the view to the window.
     * <p>Throws {@link android.view.WindowManager.BadTokenException} for certain programming
     * errors, such as adding a second view to a window without removing the first view.
     * <p>Throws {@link android.view.WindowManager.InvalidDisplayException} if the window is on a
     * secondary {@link Display} and the specified display can't be found
     * (see {@link android.app.Presentation}).
     * @param view The view to be added to this window.
     * @param params The LayoutParams to assign to view.
     */
    public void addView(View view, ViewGroup.LayoutParams params);
    public void updateViewLayout(View view, ViewGroup.LayoutParams params);
    public void removeView(View view);
}
```
WindowManager继承了ViewManager
WindowManager是个接口，它的实现是WindowManagerImpl类。而WindowManagerImpl类中将三个方法由WindowManagerGlobal来实现

## Window机制
每个Window对应这个一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系

* View才是Window的实体
* Window的操作需要通过WindowManager来操作

Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。

### Window的添加
我们通常通过WindowManager来添加、删除和更新View，WindowManager是给接口类

```java

public interface ViewManager
{
    public void addView(View view, ViewGroup.LayoutParams params);
    public void updateViewLayout(View view, ViewGroup.LayoutParams params);
    public void removeView(View view);
}
```
其实现位于WindowManagerImpl类

```java
package android.view;

public final class WindowManagerImpl implements WindowManager {
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    private final Display mDisplay;
    private final Window mParentWindow;

    public WindowManagerImpl(Display display) {
        this(display, null);
    }

    private WindowManagerImpl(Display display, Window parentWindow) {
        mDisplay = display;
        mParentWindow = parentWindow;
    }

    public WindowManagerImpl createLocalWindowManager(Window parentWindow) {
        return new WindowManagerImpl(mDisplay, parentWindow);
    }

    public WindowManagerImpl createPresentationWindowManager(Display display) {
        return new WindowManagerImpl(display, mParentWindow);
    }

    @Override
    public void addView(View view, ViewGroup.LayoutParams params) {
        mGlobal.addView(view, params, mDisplay, mParentWindow);
    }

    @Override
    public void updateViewLayout(View view, ViewGroup.LayoutParams params) {
        mGlobal.updateViewLayout(view, params);
    }

    @Override
    public void removeView(View view) {
        mGlobal.removeView(view, false);
    }

    @Override
    public void removeViewImmediate(View view) {
        mGlobal.removeView(view, true);
    }

    @Override
    public Display getDefaultDisplay() {
        return mDisplay;
    }
}

```

addView、updateView和removeView方法都是委托给WindowManagerGlobal类

WindowManagerGlobal类几个重要的成员变量:

```java
//所有Window对应的View
private final ArrayList<View> mViews = new ArrayList<View>();
//所有Window对应的ViewRootImpl
private final ArrayList<ViewRootImpl> mRoots = new ArrayList<ViewRootImpl>();
//所有Window对应的布局参数
private final ArrayList<WindowManager.LayoutParams> mParams = new ArrayList<WindowManager.LayoutParams>();
private final ArraySet<View> mDyingViews = new ArraySet<View>();

```

WindowManagerGlobal中的AddView方法：

```java
public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        //1.检查参数是否合法
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }
        if (display == null) {
            throw new IllegalArgumentException("display must not be null");
        }
        if (!(params instanceof WindowManager.LayoutParams)) {
            throw new IllegalArgumentException("Params must be WindowManager.LayoutParams");
        }

        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;
        if (parentWindow != null) {
            parentWindow.adjustLayoutParamsForSubWindow(wparams);
        } else {
            // If there's no parent and we're running on L or above (or in the
            // system context), assume we want hardware acceleration.
            final Context context = view.getContext();
            if (context != null
                    && context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
            }
        }

        ViewRootImpl root;
        View panelParentView = null;

        synchronized (mLock) {
            // Start watching for system property changes.
            if (mSystemPropertyUpdater == null) {
                mSystemPropertyUpdater = new Runnable() {
                    @Override public void run() {
                        synchronized (mLock) {
                            for (int i = mRoots.size() - 1; i >= 0; --i) {
                                mRoots.get(i).loadSystemProperties();
                            }
                        }
                    }
                };
                SystemProperties.addChangeCallback(mSystemPropertyUpdater);
            }

            int index = findViewLocked(view, false);
            if (index >= 0) {
                if (mDyingViews.contains(view)) {
                    // Don't wait for MSG_DIE to make it's way through root's queue.
                    mRoots.get(index).doDie();
                } else {
                    throw new IllegalStateException("View " + view
                            + " has already been added to the window manager.");
                }
                // The previous removeView() had not completed executing. Now it has.
            }

            // If this is a panel window, then find the window it is being
            // attached to for future reference.
            if (wparams.type >= WindowManager.LayoutParams.FIRST_SUB_WINDOW &&
                    wparams.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                final int count = mViews.size();
                for (int i = 0; i < count; i++) {
                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) {
                        panelParentView = mViews.get(i);
                    }
                }
            }
            //2.创建ViewRootImpl并将View添加到列表中
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            //调用ViewRootImpl的setViw方法
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            // BadTokenException or InvalidDisplayException, clean up.
            synchronized (mLock) {
                final int index = findViewLocked(view, false);
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
            }
            throw e;
        }
    }
```

ViewRootImpl的setView方法

```java
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
        synchronized (this) {
            if (mView == null) {
                mView = view;

                mAttachInfo.mDisplayState = mDisplay.getState();
                mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);

                mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
                mFallbackEventHandler.setView(view);
                mWindowAttributes.copyFrom(attrs);
                if (mWindowAttributes.packageName == null) {
                    mWindowAttributes.packageName = mBasePackageName;
                }
                attrs = mWindowAttributes;
                // Keep track of the actual window flags supplied by the client.
                mClientWindowLayoutFlags = attrs.flags;

                setAccessibilityFocus(null, null);

                if (view instanceof RootViewSurfaceTaker) {
                    mSurfaceHolderCallback =
                            ((RootViewSurfaceTaker)view).willYouTakeTheSurface();
                    if (mSurfaceHolderCallback != null) {
                        mSurfaceHolder = new TakenSurfaceHolder();
                        mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                    }
                }

                // Compute surface insets required to draw at specified Z value.
                // TODO: Use real shadow insets for a constant max Z.
                final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
                attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);

                CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
                mTranslator = compatibilityInfo.getTranslator();
                mDisplayAdjustments.setActivityToken(attrs.token);

                // If the application owns the surface, don't enable hardware acceleration
                if (mSurfaceHolder == null) {
                    enableHardwareAcceleration(attrs);
                }

                boolean restore = false;
                if (mTranslator != null) {
                    mSurface.setCompatibilityTranslator(mTranslator);
                    restore = true;
                    attrs.backup();
                    mTranslator.translateWindowLayout(attrs);
                }
                if (DEBUG_LAYOUT) Log.d(TAG, "WindowLayout in setView:" + attrs);

                if (!compatibilityInfo.supportsScreen()) {
                    attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                    mLastInCompatMode = true;
                }

                mSoftInputMode = attrs.softInputMode;
                mWindowAttributesChanged = true;
                mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
                mAttachInfo.mRootView = view;
                mAttachInfo.mScalingRequired = mTranslator != null;
                mAttachInfo.mApplicationScale =
                        mTranslator == null ? 1.0f : mTranslator.applicationScale;
                if (panelParentView != null) {
                    mAttachInfo.mPanelParentWindowToken
                            = panelParentView.getApplicationWindowToken();
                }
                mAdded = true;
                int res; /* = WindowManagerImpl.ADD_OKAY; */

                // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
                //3.通过View的SetView方法来完成。绘制过程由此类完成、此处通过requestLyaout来完成异步刷新请求
                requestLayout();
                if ((mWindowAttributes.inputFeatures
                        & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                    mInputChannel = new InputChannel();
                }
                try {
                    mOrigWindowType = mWindowAttributes.type;
                    mAttachInfo.mRecomputeGlobalAttributes = true;
                    collectViewAttributes();
                    //通过WindowSession来完成Winhdow添加过程。类型为IwindowSeession，这是个Binder对象，实现类为Session。IPC
                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mInputChannel);
                } catch (RemoteException e) {
                    mAdded = fal
                    mView = null;
                    mAttachInfo.mRootView = null;
                    mInputChannel = null;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    throw new RuntimeException("Adding window failed", e);
                } finally {
                    if (restore) {
                        attrs.restore();
                    }
                }

                if (mTranslator != null) {
                    mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
                }
                mPendingOverscanInsets.set(0, 0, 0, 0);
                mPendingContentInsets.set(mAttachInfo.mContentInsets);
                mPendingStableInsets.set(mAttachInfo.mStableInsets);
                mPendingVisibleInsets.set(0, 0, 0, 0);
                if (DEBUG_LAYOUT) Log.v(TAG, "Added window " + mWindow);
                if (res < WindowManagerGlobal.ADD_OKAY) {
                    mAttachInfo.mRootView = null;
                    mAdded = false;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    switch (res) {
                        case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                        case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                            throw new WindowManager.BadTokenException(
                                "Unable to add window -- token " + attrs.token
                                + " is not valid; is your activity running?");
                        case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                            throw new WindowManager.BadTokenException(
                                "Unable to add window -- token " + attrs.token
                                + " is not for an application");
                        case WindowManagerGlobal.ADD_APP_EXITING:
                            throw new WindowManager.BadTokenException(
                                "Unable to add window -- app for token " + attrs.token
                                + " is exiting");
                        case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                            throw new WindowManager.BadTokenException(
                                "Unable to add window -- window " + mWindow
                                + " has already been added");
                        case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                            // Silently ignore -- we would have just removed it
                            // right away, anyway.
                            return;
                        case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                            throw new WindowManager.BadTokenException(
                                "Unable to add window " + mWindow +
                                " -- another window of this type already exists");
                        case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                            throw new WindowManager.BadTokenException(
                                "Unable to add window " + mWindow +
                                " -- permission denied for this window type");
                        case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                            throw new WindowManager.InvalidDisplayException(
                                "Unable to add window " + mWindow +
                                " -- the specified display can not be found");
                    }
                    throw new RuntimeException(
                        "Unable to add window -- unknown error code " + res);
                }

                if (view instanceof RootViewSurfaceTaker) {
                    mInputQueueCallback =
                        ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();
                }
                if (mInputChannel != null) {
                    if (mInputQueueCallback != null) {
                        mInputQueue = new InputQueue();
                        mInputQueueCallback.onInputQueueCreated(mInputQueue);
                    }
                    mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,
                            Looper.myLooper());
                }

                view.assignParent(this);
                mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
                mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;

                if (mAccessibilityManager.isEnabled()) {
                    mAccessibilityInteractionConnectionManager.ensureConnection();
                }

                if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                    view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
                }

                // Set up the input pipeline.
                CharSequence counterSuffix = attrs.getTitle();
                mSyntheticInputStage = new SyntheticInputStage();
                InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
                InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,
                        "aq:native-post-ime:" + counterSuffix);
                InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
                InputStage imeStage = new ImeInputStage(earlyPostImeStage,
                        "aq:ime:" + counterSuffix);
                InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
                InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,
                        "aq:native-pre-ime:" + counterSuffix);

                mFirstInputStage = nativePreImeStage;
                mFirstPostImeInputStage = earlyPostImeStage;
                mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
            }
        }
    }
```

先看requestLayout()

```java
  @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread();
            mLayoutRequested = true;
            //View绘制的入口
            scheduleTraversals();
        }
    }
```
 查看IWindowSession的addToDisplay方法，此方法为IPC过程，调用Session的addToDisplay方法
 
```java
 @Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
            InputChannel outInputChannel) {
        // 通过WindoManagerService来实现Window的添加
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outStableInsets, outInputChannel);
    }
```

Window的添加、删除和更新过程都是IPC过程，以Window的添加为例，WindowManager的实现类对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类，该类保存了很多数据列表，例如所有window对应的view集合mViews、所有window对应的ViewRootImpl的集合mRoots等，之后添加操作交给了ViewRootImpl来处理，接着会通过WindowSession来完成Window的添加过程，这个过程是一个IPC调用，因为最终是通过WindowManagerService来完成window的添加的。

### Window的删除
Widow的删除和添加是相似的，先通过WindowManagerImpl后，进一步通过WindowManagerGlobal来实现，下面是RemoveView的实现：

```java
 public void removeView(View view, boolean immediate) {
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }

        synchronized (mLock) {
            //查找待删除的View的索引
            int index = findViewLocked(view, true);
            View curView = mRoots.get(index).getView();
            //删除
            removeViewLocked(index, immediate);
            if (curView == view) {
                return;
            }

            throw new IllegalStateException("Calling with view " + view
                    + " but the ViewAncestor is attached to " + curView);
        }
    }
```
首先通过findViewLocked来查找待删除的View的索引，然后掉用RemoveViewLocked来进一步删除。

```java
private void removeViewLocked(int index, boolean immediate) {
        ViewRootImpl root = mRoots.get(index);
        View view = root.getView();

        if (view != null) {
            InputMethodManager imm = InputMethodManager.getInstance();
            if (imm != null) {
                imm.windowDismissed(mViews.get(index).getWindowToken());
            }
        }
        boolean deferred = root.die(immediate);
        if (view != null) {
            view.assignParent(null);
            if (deferred) {
                mDyingViews.add(view);
            }
        }
    }
```

removeViewLocked通过ViewRootImpl完成，通过ViewRootImpl的die方法来完成，分为异步和同步两种情况

```java
 boolean die(boolean immediate) {
        // Make sure we do execute immediately if we are in the middle of a traversal or the damage
        // done by dispatchDetachedFromWindow will cause havoc on return.
        if (immediate && !mIsInTraversal) {
            doDie();
            return false;
        }

        if (!mIsDrawing) {
            destroyHardwareRenderer();
        } else {
            Log.e(TAG, "Attempting to destroy the window while drawing!\n" +
                    "  window=" + this + ", title=" + mWindowAttributes.getTitle());
        }
        mHandler.sendEmptyMessage(MSG_DIE);
        return true;
    }
```

在die方法内做判断，如果是异步删除，就发送一个MSG_DIE的消息，ViewRootImpl的Handler会处理此消息并调用doDie方法，如果是同步删除的，就不发消息直接调用doDie方法。这是两种删除的区别。在doDie内部会调用dispatchDetachedFromWindow方法，真正删除View的逻辑在dispatchDetachedFromWindow方法内部实现。

```java
void doDie() {
        checkThread();
        if (LOCAL_LOGV) Log.v(TAG, "DIE in " + this + " of " + mSurface);
        synchronized (this) {
            if (mRemoved) {
                return;
            }
            mRemoved = true;
            if (mAdded) {
                dispatchDetachedFromWindow();
            }

            if (mAdded && !mFirst) {
                destroyHardwareRenderer();

                if (mView != null) {
                    int viewVisibility = mView.getVisibility();
                    boolean viewVisibilityChanged = mViewVisibility != viewVisibility;
                    if (mWindowAttributesChanged || viewVisibilityChanged) {
                        // If layout params have been changed, first give them
                        // to the window manager to make sure it has the correct
                        // animation info.
                        try {
                            if ((relayoutWindow(mWindowAttributes, viewVisibility, false)
                                    & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                                mWindowSession.finishDrawing(mWindow);
                            }
                        } catch (RemoteException e) {
                        }
                    }

                    mSurface.release();
                }
            }

            mAdded = false;
        }
        //调用WindowManagerGlobal的doRemoveView方法刷新数据如mRoots、mParams以及mDayingViews、将当前Window所关联的这三类对象从列表中删除
        WindowManagerGlobal.getInstance().doRemoveView(this);
    }
```

```java
 void dispatchDetachedFromWindow() {
        if (mView != null && mView.mAttachInfo != null) {
            mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false);
            //调用View的dispatchDetachedFromWindow方法，在内部会调用View的onDetachedFromWiondow以及onDetachedFromWindowInternal()。当View从Window中移除时，这个方法被调用。可以在这个方法中做一些资源回收的工作。
            mView.dispatchDetachedFromWindow();
        }

        mAccessibilityInteractionConnectionManager.ensureNoConnection();
        mAccessibilityManager.removeAccessibilityStateChangeListener(
                mAccessibilityInteractionConnectionManager);
        mAccessibilityManager.removeHighTextContrastStateChangeListener(
                mHighContrastTextManager);
        removeSendWindowContentChangedCallback();

        destroyHardwareRenderer();

        setAccessibilityFocus(null, null);

			//垃圾回收的工作，清除数据、移除回调
        mView.assignParent(null);
        mView = null;
        mAttachInfo.mRootView = null;

        mSurface.release();

        if (mInputQueueCallback != null && mInputQueue != null) {
            mInputQueueCallback.onInputQueueDestroyed(mInputQueue);
            mInputQueue.dispose();
            mInputQueueCallback = null;
            mInputQueue = null;
        }
        if (mInputEventReceiver != null) {
            mInputEventReceiver.dispose();
            mInputEventReceiver = null;
        }
        //删除Window IPC 通过Session的remove方法删除Window；最终会调用WindowManagerService的removewWindow方法。
        try {
            mWindowSession.remove(mWindow);
        } catch (RemoteException e) {
        }

        // Dispose the input channel after removing the window so the Window Manager
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }

        mDisplayManager.unregisterDisplayListener(mDisplayListener);

        unscheduleTraversals();
    }
```

### Window的更新

Window的跟新过程由WindowManagerGloba的updateViewLayout方法：

```java
public void updateViewLayout(View view, ViewGroup.LayoutParams params) {
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }
        if (!(params instanceof WindowManager.LayoutParams)) {
            throw new IllegalArgumentException("Params must be WindowManager.LayoutParams");
        }

        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;

        // 更新View中的LayoutParams
        view.setLayoutParams(wparams);

        synchronized (mLock) {
            int index = findViewLocked(view, true);
            ViewRootImpl root = mRoots.get(index);
            mParams.remove(index);
            mParams.add(index, wparams);
            //更新ViewRootImpl的LayoutParams
            // 在ViewRootImpl中通过ScheduleTraversals对View重新布局
            // 并通过WindowSession来更新Window的视图，这个过程最终调用了WindwManagerServiece的relaytWindow（）来具体实现，同样是一个IPC过程
            root.setLayoutParams(wparams, false);
        }
    }
```

(1)Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。
(2)Window的添加、删除和更新过程都是IPC过程，以Window的添加为例，WindowManager的实现类对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类，该类保存了很多数据列表，例如所有window对应的view集合mViews、所有window对应的ViewRootImpl的集合mRoots等，之后添加操作交给了ViewRootImpl来处理，接着会通过WindowSession来完成Window的添加过程，这个过程是一个IPC调用，因为最终是通过WindowManagerService来完成window的添加的。

其实窗口的概念，从不同的角度来看，其含义是不一样的。我们知道，WindowManagerService（后面简称 WmS）管理所有的窗口。但是对于WmS来讲，一个窗口其实就是一个 View 类，而不是 Window 类。WmS 负责管理这些 View 的 Z-order，显示区域，以及把消息派发到对应的 View 中。


<!--View 本身并不能直接从 WmS 中接收消息，而是通过实现了 IWindow 接口的 ViewRootImpl.W 类来实现，
所以这里窗口分为两层概念：

（1）WmS 眼中的，窗口是可以显示用来显示的 View。对于 WmS 而言，所谓的窗口就是一个通过 WindowManagerGlobal.addView()添加的 View 罢了；<br>
（2）Window 类是一个针对窗口交互的抽象，也就是对于 WmS 来讲所有的用户消息是直接交给 View/ViewGroup 来处理的。而 Window 类把一些交互从 View/ViewGroup 中抽离出来，定义了一些窗口的行为，例如菜单，以及处理系统按钮，如“Home”，“Back”等等。由此可见，Window 描述的窗口只是在通用窗口的基础上，再抽象了一层，把符合某种规范的窗口统一了一下。Window 所描述的窗口，应该是通用窗口的一个子集。例如 PopupWindow 是一个窗口，但是分析其源码可以知道，该类并没有创建任何 Window 对象。而 Dialog 则是通过 PolicyManager.makeNewWindow(mContext) 创建了一个 Window 对象来管理窗口。当一个 Dialog 显示时，我们可以通过按 back 把它 dismiss 了，但是 PopupWindow 则不行，需要自己去处理。 
-->

<img src="/images/posts/Android_Window/2.png" width="80%"/>

## Activity中的Window创建机制
* Activity的启动过程很复杂，最终会由ActivityThread中的performLaunchActivity来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用它的attach方法为其关联运行过程中所依赖的一系列上下文环境变量；

```java
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        // System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");

        ActivityInfo aInfo = r.activityInfo;
        if (r.packageInfo == null) {
            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                    Context.CONTEXT_INCLUDE_CODE);
        }

        ComponentName component = r.intent.getComponent();
        if (component == null) {
            component = r.intent.resolveActivity(
                mInitialApplication.getPackageManager());
            r.intent.setComponent(component);
        }

        if (r.activityInfo.targetActivity != null) {
            component = new ComponentName(r.activityInfo.packageName,
                    r.activityInfo.targetActivity);
        }

        Activity activity = null;
        try {
            //1.使用ClassLoader从程序文件中装载指定的Activity对应的Class
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to instantiate activity " + component
                    + ": " + e.toString(), e);
            }
        }

        try {
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            if (localLOGV) Slog.v(TAG, "Performing launch of " + r);
            if (localLOGV) Slog.v(
                    TAG, r + ": app=" + app
                    + ", appName=" + app.getPackageName()
                    + ", pkg=" + r.packageInfo.getPackageName()
                    + ", comp=" + r.intent.getComponent().toShortString()
                    + ", dir=" + r.packageInfo.getAppDir());

            if (activity != null) {
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
                        + r.activityInfo.name + " with config " + config);
                //2.构造了指定的Activity对象后，调用Activity的attch()方法
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor);

                if (customIntent != null) {
                    activity.mIntent = customIntent;
                }
                r.lastNonConfigurationInstances = null;
                activity.mStartedActivity = false;
                int theme = r.activityInfo.getThemeResource();
                if (theme != 0) {
                    activity.setTheme(theme);
                }

                activity.mCalled = false;
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
                r.activity = activity;
                r.stopped = true;
                if (!r.activity.mFinished) {
                    activity.performStart();
                    r.stopped = false;
                }
                if (!r.activity.mFinished) {
                    if (r.isPersistable()) {
                        if (r.state != null || r.persistentState != null) {
                            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                                    r.persistentState);
                        }
                    } else if (r.state != null) {
                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
                    }
                }
                if (!r.activity.mFinished) {
                    activity.mCalled = false;
                    if (r.isPersistable()) {
                        mInstrumentation.callActivityOnPostCreate(activity, r.state,
                                r.persistentState);
                    } else {
                        mInstrumentation.callActivityOnPostCreate(activity, r.state);
                    }
                    if (!activity.mCalled) {
                        throw new SuperNotCalledException(
                            "Activity " + r.intent.getComponent().toShortString() +
                            " did not call through to super.onPostCreate()");
                    }
                }
            }
            r.paused = true;

            mActivities.put(r.token, r);

        } catch (SuperNotCalledException e) {
            throw e;

        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to start activity " + component
                    + ": " + e.toString(), e);
            }
        }

        return activity;
    }
}
```

* Activity实现了Window的Callback接口，当window接收到外界的状态变化时就会回调Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等；


* Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的；

```java
//Activity类

    //作用：给刚构造的Activity设置内部变量,包括Window对象
    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, IVoiceInteractor voiceInteractor) {
        attachBaseContext(context);

        mFragments.attachActivity(this, mContainer, null);

        //创建Activity所属的Window对象
        //Activity的Window是通过PolicyManager的一个工厂方法来创建的
        //策略类
        mWindow = PolicyManager.makeNewWindow(this);
        //设置回调，所以用户信息可以传递回Activity
        mWindow.setCallback(this);
        mWindow.setOnWindowDismissedCallback(this);
        mWindow.getLayoutInflater().setPrivateFactory(this);
        if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
            mWindow.setSoftInputMode(info.softInputMode);
        }
        if (info.uiOptions != 0) {
            mWindow.setUiOptions(info.uiOptions);
        }
        mUiThread = Thread.currentThread();

        mMainThread = aThread;
        mInstrumentation = instr;
        mToken = token;
        mIdent = ident;
        mApplication = application;
        mIntent = intent;
        mComponent = intent.getComponent();
        mActivityInfo = info;
        mTitle = title;
        mParent = parent;
        mEmbeddedID = id;
        mLastNonConfigurationInstances = lastNonConfigurationInstances;
        if (voiceInteractor != null) {
            if (lastNonConfigurationInstances != null) {
                mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;
            } else {
                mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,
                        Looper.myLooper());
            }
        }

        mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
    }
```

```java
    //策略类
    //实际调用Policy类
    public interface IPolicy {
    public Window makeNewWindow(Context context);

    public LayoutInflater makeNewLayoutInflater(Context context);

    public WindowManagerPolicy makeNewWindowManager();

    public FallbackEventHandler makeNewFallbackEventHandler(Context context);



    //PolicyManager的真正实现类是Policy类
    public Window makeNewWindow(Context context) {
        return new PhoneWindow(context);
    }

```

```java
    //Actigvity视图如何附属在Window
    //Activity的视图由SetContentView完成

    /**
     * Set the activity content from a layout resource.  The resource will be
     * inflated, adding all top-level views to the activity.
     *
     * @param layoutResID Resource ID to be inflated.
     *
     * @see #setContentView(android.view.View)
     * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
     */
    public void setContentView(int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    }
```
* Activity的顶级View是DecorView，它本质上是一个FrameLayout。如果没有DecorView，那么PhoneWindow会先创建一个DecorView，然后加载具体的布局文件并将view添加到DecorView的mContentParent中，最后就是回调Activity的onContentChanged通知Activity视图已经发生了变化；

```java

//PhoneWidnow
 @Override
    public void setContentView(int layoutResID) {
        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
        // decor, when theme attributes and the like are crystalized. Do not check the feature
        // before this happens.
        if (mContentParent == null) {
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                    getContext());
            transitionTo(newScene);
        } else {
        //2.
            mLayoutInflater.inflate(layoutResID, mContentParent);
        }
        final Callback cb = getCallback();
        if (cb != null && !isDestroyed()) {
        //3.
            cb.onContentChanged();
        }
    }
    
    
    private void installDecor() {
        if (mDecor == null) {
            mDecor = generateDecor();
            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            mDecor.setIsRootNamespace(true);
            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {
                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
            }
        }
        if (mContentParent == null) {
            mContentParent = generateLayout(mDecor);
            ...
   }
    

    //installDecor()中会通过
    protected DecorView generateDecor() {
        return new DecorView(getContext(), -1);
    }
    

    //此时DecorView只是一个空白的FrameLayout，
    //PhoeWindow还需要通过generateLayout方法来加载布局文件到DecorView，具体的布局文件和系统版本和主题有关
    View in = mLayoutInflater.inflate(layoutResource, null);
    decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    mContentRoot = (ViewGroup) in;
    //
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);


    /**
     * The ID that the main layout in the XML layout file should have.
     */
    public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;
    //2、将View添加到DecorView的mContientPanret
    // 在第一步中初始化了DecorView，直接将Activity的视图添加到DecorView的mContentParent中
        mLayoutInflater.inflate(layoutResID, mContentParent);


    //3.回调Activity的OnContentChanged方法通知Activity视图发生该改变
    //Acitivity实现了Window的CallBack接口  Activty布局文件邮件泰诺健到DecorView的mContent中了，通知Activity。
        onContentChanged

```

* 还有一个步骤是让WindowManager能够识别DecorView，在ActivityThread调用handleResumeActivity方法时，首先会调用Activity的onResume方法，然后会调用makeVisible方法，这个方法中DecorView真正地完成了添加和显示过程。

```java
void makeVisible() {
     if (!mWindowAdded) {
        ViewManager wm = getWindowManager();
        wm.addView(mDecor, getWindow().getAttributes());
        mWindowAdded = true;
     }
     mDecor.setVisibility(View.VISIBLE);
}
```

### 小结
我们知道每个 Activity 对应一个 PhoneWindow，当我们调用 setContentView 时，其实最终结果是把我们的 View 树作为子 View 添加到 PhoneWindow 的 DecorView 中。也就是每个 Activity 的根 View 其实是一个 DecorView。而最终这个 DecorView，又是在 ActivityThread 的 handleResumeActivity 方法中，通过 WindowMnagerImpl 的 addView 方法添加到 WmS 中去的。 PhoneWindow 的 setContentView 又做了哪些事情呢？只是通过 installDecor()方法，给窗口初始化一了些装饰。而所谓的装饰就是指界面上看到的标题栏，导航栏 ActionBar。而我们通过 Activity 的 setContentView 设置的 View，是作为窗口的内容(如下图所示，是作为ID为android.R.content 的 FrameLayout 的子 View)。这里，我们是不是就理解了，窗口的标题栏是如何被添加的。以及窗口的一些属性为什么要在 setContentView 调用之前被设置了。因为，generateLayout 方法负责根据窗口的属性，最终决定采用不同的布局来生成窗口的顶层布局。而 generateLayout 只在 mContentParent 为 null 的时候被调用，而 mContentParent 只有在第一次调用 setContentView 时为 null，此后就不再为 null 了。

<img src="/images/posts/Android_Window/3.png" width="80%"/>

<!--从上面的图可以知道，PhoneWindow 只是负责处理一些应用窗口通用的逻辑。但是真正完成把一个 View，作为窗口添加到 WmS 的过程是由 WindowManager 来完成的。WindowManager 在应用程序端的实现是 WindowManagerImpl，也就是说，我们通过 Activity 的 getWindowManager 获取到的实际上是 WindowManagerImpl。因此在在 ActivityThread 的 handleResumeActivity 方法中，有调用 WindowManagerImpl 的 addView，把 PhoneWindow 准备好的 DecorView 作为窗口添加到 WmS 中。

<img src="/images/posts/Android_Window/4.png" width="80%"/>

窗口的添加过程如上图所示，我们知道 WmS 运行在单独的进程中。这里 IWindowSession 执行的 addtoDisplay 操作应该是 IPC 调用。每个应用窗口创建时，都会创建一个 ViewRootImpl 对象。分析了后面子窗口的创建，以及系统窗口的创建后，我们会知道其实任何一个窗口的创建，最终都是会创建一个 ViewRootImpl对象。ViewRootImpl 是一很重要的类，类似 ActivityThread 负责跟AmS通信一样，ViewRootImpl 的一个重要职责就是跟 WmS 通信，它通静态变量 sWindowSession（IWindowSession实例）与 WmS 进行通信。每个应用进程，仅有一个 sWindowSession 对象，它对应了 WmS 中的 Session 子类，WmS 为每一个应用进程分配一个 Session 对象。WindowState 类有一个 IWindow mClient 参数，是在构造方法中赋值的，是由 Session 调用 addWindow 传递过来了，对应了 ViewRootImpl 中的 W 类的实例。

<img src="/images/posts/Android_Window/5.png" width="80%"/>
-->

## Activity添加到客户端窗口的过程
在应用初始化的时候，会首先生成一个Activity对象，此时该activity还没有属于他的一个窗口。紧接着通过调用attach()函数，在attach()函数里面该activity会调用PolicyManager.makeNewWindow()创建一个新的PhoneWindow，然后在activity的onCreate（）生命周期里，一般应用都会调用setContentView（）设置该activity的显示界面。在setContentView()里，框架会自动生成一个布局，该布局文件包含了如标题栏、ActionBar等元素，最重要的是包含了应用的contentView。这个布局对应的就是PhoneWindow里面的mDecorView。最后在activity将要显示出来之前，通过getWindow().getDecorView()获取到DecorView，并通过WindowManager.addView()把DecorView添加到WindowManager中。

<img src="/images/posts/Android_Window/6.png" width="80%"/>

## 窗口管理
Android的窗关管理是基于C/S模式的，并且使用独立进程的方式实现。窗口管理的服务端WindowManagerService运行在独立的进程system_server里，当应用程序需要创建窗口时，通过进程通信的方式请求WindowManagerService创建窗口，由WindowManagerService向应用程序传递和窗口相关的交互消息。所有程序的窗口都在服务端管理，窗口的显示和控制都在WindowManagerService里处理。

WindowManagerService主要完成了以下几部分功能：

* 窗口的添加和删除
* 窗口的显示和隐藏控制
* Z-order顺序管理
* 焦点窗口和焦点应用的管理
* 输入法窗口管理和墙纸窗口管理
* 转场动画
* 系统消息收集和分发

服务端的实现代码是在/framework/base/services/java/com/android/server/wm/里，核心的几个类是：
WindowManagerService.java
WindowState.java
WindowToken.java
AppWindowToken.java
Session.java
InputManager.java
InputMonitor.java

WindowManagerService负责完成窗口的管理工作；

WindowState和客户端窗口一一对应，应用调用WindowManager.addView()时，最终会在WindowManagerService添加一个WindowState与之一一对应。

WindowToken是一个句柄，保存了所有具有同一个token的WindowState。应用请求WindowManagerService添加窗口的时候，提供了一个token，该token标识了被添加窗口的归属，WindowManagerService为该token生成一个WindowToken对象，所有token相同的WindowState被关联到同一个WindowToken。如输入法添加窗口时，会传递一个mCurrToken，墙纸服务添加窗口时，会传递一个newConn.mToken。

AppWindowToken继承于WindowToken，专门用于标识一个Activity。AppWindowToken里的token实际上就是指向了一个Activity。ActivityManagerService通知应用启动的时候，在服务端生成一个token用于标识该Activity，并且把该token传递到应用客户端，客户端的Activity在申请添加窗口时，以该token作为标识传递到WindowManagerService。同一个Activity中的主窗口、对话框窗口、菜单窗口都关联到同一个AppWindowToken。

Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。

InputManager和InputMonitor负责上层的消息分发功能。

WindowManagerService内部的几个重要成员变量：
ArrayList<WindowState>         mWindows
HashMap<IBinder, WindowState>         mWindowMap
ArrayList<WindowToken>        mTokenList
ArrayList<AppWindowToken>         mAppTokens
 

mWindows保存了系统中所有的WindowState；

mWindowMap保存了每个WindowState和客户端窗口的映射关系，客户端应用请求窗口操作时，通过mWindowMap查询到对应的WindowState；
mTokenList保存了所有的WindowToken
mAppTokens保存了所有的AppWindowToken

<img src="/images/posts/Android_Window/7.png" width="80%"/>

## Activity从启动到添加窗口的整个流程
ActivityManagerService在接收到启动Activity请求时，首先生成一个token作为该Activity的唯一标识。然后调用WindowManagerService向其添加一个AppWindowToken，此AppWindowToken封装了Activity的token。接着AMS启动应用客户端进程并把token传递到该进程，在客户端进程里完成Activity的初始化。在Activity的attach()函数中，Activity完成PhoneWindow的创建，并且把token传递给PhoneWindow。在Activity调用WindowManager.addView()时，在WindowManager内部会把token和该View关联，真正向WindowManagerService申请创建窗口的时候，再把token传递给WindowManagerService。WindowManagerService接收到创建窗口的请求的时候，通过mTokenMap查询对应该token的AppWindowToken，如果为空则抛出异常，否则创建一个WindowState并完成初始化工作和其他数据结构的调整工作。在这个过程中，token贯穿了服务端的AMS、WMS和客户端的Activity、Window。

<img src="/images/posts/Android_Window/8.png" width="80%"/>

## WMS中服务端和客户端的交互接口和数据结构

应用请求创建窗口时，和应用直接交互的是WindowManager对象。WindowManager只是一个接口，调用addView()创建窗口时正真交互的是WindowManagerImpl对象。WindowManagerImpl管理单个应用的所有本地窗口。应用调用addView()创建窗口时，WindowManagerImpl会生成一个ViewRoot对象与之相对应，并且把相应的参数LayoutParams保存起来。

addView()的执行流程如下：

1. 检查所添加的窗口是否已经添加过，不允许重复添加；
2. 如果所添加窗口为子窗口类型，找到其父窗口，并保存在内部变量中；
3. 创建一个新的ViewRoot，并保存对应的View（DecorView）和LayoutParams；
4. 调用ViewRoot的setView()方法，完成真正意义上的添加工作。
 
ViewRoot本质上是一个Handler，并且实现了ViewParent接口。ViewRoot的主要功能是：

1. 负责分发消息事件，如Key、Motion事件等；
2. 负责和WMS的交互，分发WMS的交互命令；
3. 作为DecorView的parent，对DecorView进行draw、measure、layout等操作；

在addView()的第3、4步完成之后，ViewRoot就全权接管了和WMS的交互工作，DecorView不需要做任何交互动作。ViewRoot和WMS之间的双向对话，主要是通过以下两个数据结构进行的：
IWindowSession
IWindow
这两个数据结构都是标准的aidl接口，用于进程之间的同步通信。IWindowSession负责ViewRoot到WMS的单向请求，IWindow则用于WMS回调ViewRoot。在ViewRoot对象内部，存在着一个IWindowSession的静态成员和一个IWindow的非静态成员，所以一个进程里只有一个IWindowSession对象，但是可以有多个IWindow对象。
Window、WindowManager、DecorView、ViewRoot、IWindowSession、IWindowSession、WindowState、WindowManagerService之间的关系可用下图来表示：

<img src="/images/posts/Android_Window/9.png" width="80%"/>

在ViewRoot的构造函数中，调用getWindowSession()初始化静态成员sWindowSession和非静态成员mWindow。在第4步调用setView()方法时，ViewRoot会调用sWindowSession.add()方法，把IWindow添加到WMS中，WMS就会生成一个WindowState与之一一对应，并且把IWindow对象保存到WindowState内部作为回调的接口。之后所有WMS的命令，都会通过直接访问IWindow接口，以消息的形式分发到ViewRoot，ViewRoot来完成相应的处理，或对DecorView进行操作，或完成后通过sWindowSession报告给WMS。

<img src="/images/posts/Android_Window/10.png" width="80%"/>

这里梳理了一下，这些类的对应关系。由此可以看到，创建一个窗口的本质过程，就是在 WmS 端创建一个用来表示这个窗口的 WindowState 对象。 WmS 负责管理这里些 WindowState 对象。

<img src="/images/posts/Android_Window/11.png" width="80%"/>


## 窗口从添加到显示的时序图

整个窗口管理系统整体架构可表示如下：

<img src="/images/posts/Android_Window/12.png" width="80%"/>




